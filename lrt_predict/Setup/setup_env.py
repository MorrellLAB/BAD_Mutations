#!/usr/bin/env python
#   A script to setup the LRT prediction environment
#   Will create and parse a configuration file

#   Import standard library modules here
from distutils import spawn
import datetime

#   Import the file functions script
from ..General import file_funcs
#   Import the script to give verbose messages
from ..General import set_verbosity

class SetupEnv:
    def __init__(self, verbose):
        self.mainlog = set_verbosity.verbosity('Setup_Env', verbose)
        return

    #   A function to set the user-specified variables
    def set_user_vars(self, base, evalue, 
                 model, missingness, cfg):
        self.base = base
        self.eval_thresh = str(evalue)
        self.alignment_model = model
        self.miss_thresh = str(missingness)
        self.config_file = cfg
        self.mainlog.debug('Config file in ' + self.config_file + '\n' +\
            'Setting variables: \n' +\
            '#define BASE ' + self.base + '\n' +\
            '#define EVAL_THRESHOLD ' + self.eval_thresh + '\n' +\
            '#define MISSING_THRESHOLD ' + self.miss_thresh + '\n' +\
            '#define PRANK_MODEL ' + self.alignment_model)
        return

    #   A function to get the executable paths
    def get_exe_paths(self):
        #   We go through one-by-one and gather the paths to the required
        #   executables. This is a bit of a pain, but we do it this way to
        #   explicitly name each variable
        #       spawn.find_executable() returns NoneType if the exe is not found
        #       this lets us use it with an `or' to set the path to the empty
        #       string if the program is not found
        self.bash_path = spawn.find_executable('bash') or ''
        self.gzip_path = spawn.find_executable('gzip') or ''
        self.sum_path = spawn.find_executable('sum') or ''
        self.tblastx_path = spawn.find_executable('tblastx') or ''
        self.prank_path = spawn.find_executable('prank') or ''
        self.hyphy_path = spawn.find_executable('HYPHYSP') or ''
        self.mainlog.debug('Setting executable path variables:\n' +\
            '#define BASH ' + self.bash_path + '\n' +\
            '#define GZIP ' + self.gzip_path + '\n' +\
            '#define SUM ' + self.sum_path + '\n' +\
            '#define TBLASTX ' + self.tblastx_path + '\n' +\
            '#define PRANK ' + self.prank_path + '\n' +\
            '#define HYPHY ' + self.hyphy_path)
        #   Print out some warnings if executables are not found
        if self.bash_path == '':
            self.mainlog.warning('Cannot find bash!')
        if self.gzip_path == '':
            self.mainlog.warning('Cannot find gzip!')
        if self.sum_path == '':
            self.mainlog.warning('Cannot find sum!')
        if self.tblastx_path == '':
            self.mainlog.warning('Cannot find tblastx!')
        if self.prank_path == '':
            self.mainlog.warninig('Cannot find prank!')
        if self.hyphy_path == '':
            self.mainlog.warning('Cannot find HYPHYSP!')
        return

    #   A function to write the variables into a file
    def write_config(self):
        handle = open(self.config_file, 'w')
        #   We write this in a format that is similar to that used by structure
        gen_time = str(datetime.datetime.now())
        handle.write('// Generated by \'setup\' at ' + gen_time + '\n')
        handle.write('#define BASE ' + self.base + '\n')
        handle.write('#define EVAL_THRESHOLD ' + self.eval_thresh + '\n')
        handle.write('#define MISSING_THRESHOLD ' + self.miss_thresh + '\n')
        handle.write('#define PRANK_MODEL ' + self.alignment_model + '\n')
        handle.write('\n// Program paths\n')
        handle.write('#define BASH ' + self.bash_path + '\n')
        handle.write('#define GZIP ' + self.gzip_path + '\n')
        handle.write('#define SUM ' + self.sum_path + '\n')
        handle.write('#define TBLASTX ' + self.tblastx_path + '\n')
        handle.write('#define PRANK ' + self.prank_path + '\n')
        handle.write('#define HYPHY ' + self.hyphy_path + '\n')
        handle.flush()
        handle.close()
        self.mainlog.info('Wrote configuration into ' + self.config_file)
        return
